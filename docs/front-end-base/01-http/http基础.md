---
title: http基础
date: 2021/4/20
tags:
  - maidianjiankong
categories:
  - javascript
permalink: /docs/front-end-base/7d5ea1ff.html
---

## OSI七层模型

![img](https://whimuc.com/3jgxgBdpL39DUnFDcXccnP/DCwZT8dm13UPWR.png)

| 模型       | 概述                                                   | 单位   |
| ---------- | ------------------------------------------------------ | ------ |
| 物理层     | 网络连接介质，如网线、光缆，数据在其中以比特为单位传输 | bit    |
| 数据链路层 | 数据链路层将比特封装成数据帧并传递                     | 帧     |
| 网络层     | 定义IP地址，定义路由功能，建立主机到主机的通信         | 数据包 |
| 传输层     | 负责将数据进行可靠或者不可靠传递，建立端口到端口的通信 | 数据段 |
| 会话层     | 控制应用程序之间会话能力，区分不同的进程               |        |
| 表示层     | 数据格式标识，基本压缩加密功能                         |        |
| 应用层     | 各种应用软件                                           |        |
|            |                                                        |        |

## 报文

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：

请求行（request line）、请求头部（header）、请求体组成，下图给出了请求报文的一般格式。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/16/162cdac93015af8f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

```
请求行:
    方法:
        GET 获取资源
        POST 向服务器端发送数据，传输实体主体
        PUT 传输文件
        HEAD 获取报文首部
        DELETE 删除文件
        OPTIONS 询问支持的方法
        TRACE 追踪路径
    协议/版本号
    URL

请求头:
    通用首部(General Header)
    请求首部(Request Header)
    响应首部(Response Header)
    实体首部(Entity Header Fields)

请求体
```

请求报文拆解：

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/16/162cdb040f143019~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

### GET请求

![img](https://raw.githubusercontent.com/CNsixgod/oss-img/master/162cdadfefe0687c%7Etplv-t2oaga2asx-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp)

### POST请求

![img](https://whimuc.com/3jgxgBdpL39DUnFDcXccnP/9yygQBUbwP7saZ.png)

### GET请求和POST请求有何区别

标准答案：

- GET请求参数放在URL上，POST请求参数放在请求体里
- GET请求参数长度有限制，POST请求参数长度可以非常大
- POST请求相较于GET请求安全一点点，因为GET请求的参数在URL上，且有历史记录
- GET请求能缓存，POST不能

更进一步：

其实HTTP协议并没有要求GET/POST请求参数必须放在URL上或请求体里，也没有规定GET请求的长度，目前对URL的长度限制，是各家浏览器设置的限制。GET和POST的根本区别在于：**GET请求是幂等性的，而POST请求不是**

幂等性，指的是对某一资源进行一次或多次请求都具有相同的副作用。例如搜索就是一个幂等的操作，而删除、新增则不是一个幂等操作。

由于GET请求是幂等的，在网络不好的环境中，GET请求可能会重复尝试，造成重复操作数据的风险，因此，GET请求用于无副作用的操作(如搜索)，新增/删除等操作适合用POST。

通用头（请求头和响应头都有的首部）

| 字段              | 作用                                   | 值                                                           |
| ----------------- | -------------------------------------- | ------------------------------------------------------------ |
| Cache-Control     | 控制缓存                               | public：表示响应可以被任何对象缓存(包括客户端/代理服务器) private(默认值)：响应只能被单个客户缓存,不能被代理服务器缓存 no-cache：缓存要经过服务器验证，在浏览器使用缓存前，会对比ETag，若没变则返回304，使用缓存 no-store：禁止任何缓存 |
| Connection        | 是否需要持久连接(HTTP 1.1默认持久连接) | keep-alive / close                                           |
| Transfer-Encoding | 报文主体的传输编码格式                 | chunked(分块) / identity(未压缩和修改) / gzip(LZ77压缩) / compress(LZW压缩,弃用) / deflate(zlib结构压缩) |

请求头

| 字段                | 作用                                                         | 值                                                           |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Accept              | 告知（服务器）客户端可以处理的内容类型                       | text/html、image/*、*/*                                      |
| If-Modified-Since   | 将`Last-Modified`的值发送给服务器，询问资源是否已经过期(被修改)，过期则返回新资源，否则返回304 | 示例：If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT       |
| If-Unmodified-Since | 将`Last-Modified`的值发送给服务器，询问文件是否被修改，若没有则返回200，否则返回412预处理错误，可用于断点续传。通俗点说`If-Unmodified-Since`是文件没有修改时下载，`If-Modified-Since`是文件修改时下载 | 示例：If-Unmodified-Since: Wed, 21 Oct 2015 07:28:00 GMT     |
| If-None-Match       | 将ETag的值发送给服务器，询问资源是否已经过期(被修改)，过期则返回新资源，否则返回304 | 示例：If-None-Match: "bfc13a6472992d82d"                     |
| If-Match            | 将ETag的值发送给服务器，询问文件是否被修改，若没有则返回200，否则返回412预处理错误，可用于断点续传 | 示例：If-Match: "bfc129c88ca92d82d"                          |
| Range               | 告知服务器返回文件的哪一部分, 用于断点续传                   | 示例：Range: bytes=200-1000, 2000-6576, 19000-               |
| Host                | 指明了服务器的域名（对于虚拟主机来说），以及（可选的）服务器监听的TCP端口号 | 示例：Host:www.baidu.com                                     |
| User-Agent          | 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本    | User-Agent: Mozilla|

响应头

| 字段     | 作用                                                         | 语法                 |
| -------- | ------------------------------------------------------------ | -------------------- |
| Location | 需要将页面重新定向至的地址。一般在响应码为3xx的响应中才会有意义 | Location: < url >      |
| ETag     | 资源的特定版本的标识符，如果内容没有改变，Web服务器不需要发送完整的响应 | ETag: "< etag_value >" |
| Server   | 处理请求的源头服务器所用到的软件相关信息                     | Server: < produc t>    |

实体头（针对请求报文和响应报文的实体部分使用首部）

| 字段          | 作用                                                         | 语法                                                         |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Allow         | 资源可支持http请求的方法                                     | Allow: < http-methods >，示例：Allow: GET, POST, HEAD          |
| Last-Modified | 资源最后的修改时间，用作一个验证器来判断接收到的或者存储的资源是否彼此一致，精度不如ETag | 示例：Last-Modified: Wed, 21 Oct 2020 07:28:00 GMT           |
| Expires       | 响应过期时间                                                 | Expires: < http-date >，示例：Expires: Wed, 21 Oct 2020 07:28:00 GMT |

## htpp状态码

2xx 开头（请求成功）

`200 OK`：客户端发送给服务器的请求被正常处理并返回

3xx 开头（重定向）

`301 Moved Permanently`：永久重定向，请求的网页已永久移动到新位置。 服务器返回此响应时，会自动将请求者转到新位置

`302 Moved Permanently`：临时重定向，请求的网页已临时移动到新位置。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

`304 Not Modified`：未修改，自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容

4xx 开头（客户端错误）

`400 Bad Request`：错误请求，服务器不理解请求的语法，常见于客户端传参错误

`401 Unauthorized`：未授权，表示发送的请求需要有通过 HTTP 认证的认证信息，常见于客户端未登录

`403 Forbidden`：禁止，服务器拒绝请求，常见于客户端权限不足

`404 Not Found`：未找到，服务器找不到对应资源

5xx 开头（服务端错误）

`500 Inter Server Error`：服务器内部错误，服务器遇到错误，无法完成请求

`501 Not Implemented`：尚未实施，服务器不具备完成请求的功能

`502 Bad Gateway`：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。

`503 service unavailable`：服务不可用，服务器目前无法使用（处于超载或停机维护状态）。通常是暂时状态。

## HTTP/1.0和HTTP/1.1有什么区别

- **长连接：** HTTP/1.1支持长连接和请求的流水线，在一个TCP连接上可以传送多个HTTP请求，避免了因为多次建立TCP连接的时间消耗和延时
- **缓存处理：** HTTP/1.1引入`Entity tag，If-Unmodified-Since, If-Match, If-None-Match`等新的请求头来控制缓存，详见浏览器缓存小节
- **带宽优化及网络连接的使用：** HTTP1.1则在请求头引入了range头域，支持断点续传功能
- **Host头处理：** 在HTTP/1.0中认为每台服务器都有唯一的IP地址，但随着虚拟主机技术的发展，多个主机共享一个IP地址愈发普遍，HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会400错误

## HTTP/2.0新特性

- **多路复用：** 即多个请求都通过一个TCP连接并发地完成
- **服务端推送：** 服务端能够主动把资源推送给客户端
- **新的二进制格式：** HTTP/2采用二进制格式传输数据，相比于HTTP/1.1的文本格式，二进制格式具有更好的解析性和拓展性
- **header压缩：** HTTP/2压缩消息头，减少了传输数据的大小

## HTTP/2.0多路复用基本原理以及解决的问题

- **TCP慢启动：** TCP连接建立后，会经历一个先慢后快的发送过程，就像汽车启动一般，如果我们的网页文件(HTML/JS/CSS/icon)都经过一次慢启动，对性能是不小的损耗。另外慢启动是TCP为了减少网络拥塞的一种策略，我们是没有办法改变的。
- **多条TCP连接竞争带宽：** 如果同时建立多条TCP连接，当带宽不足时就会竞争带宽，影响关键资源的下载。
- **HTTP/1.1队头阻塞：** 尽管HTTP/1.1长链接可以通过一个TCP连接传输多个请求，但同一时刻只能处理一个请求，当前请求未结束前，其他请求只能处于阻塞状态。

为了解决以上几个问题，**HTTP/2一个域名只使用一个TCP⻓连接来传输数据，而且请求直接是并行的、非阻塞的，这就是多路复用**

**实现原理：** HTTP/2引入了一个二进制分帧层，客户端和服务端进行传输时，数据会先经过二进制分帧层处理，转化为一个个带有请求ID的帧，这些帧在传输完成后根据ID组合成对应的数据。

## HTTP/3.0

尽管HTTP/2解决了很多1.1的问题，但HTTP/2仍然存在一些缺陷，这些缺陷并不是来自于HTTP/2协议本身，而是来源于底层的TCP协议，我们知道TCP链接是可靠的连接，如果出现了丢包，那么整个连接都要等待重传，HTTP/1.1可以同时使用6个TCP连接，一个阻塞另外五个还能工作，但HTTP/2只有一个TCP连接，阻塞的问题便被放大了。

由于TCP协议已经被广泛使用，我们很难直接修改TCP协议，基于此，HTTP/3选择了一个折衷的方法——UDP协议，HTTP/2在UDP的基础上实现多路复用、0-RTT、TLS加密、流量控制、丢包重传等功能

参考资料：

[http发展史(http0.9、http1.0、http1.1、http2、http3)梳理笔记](https://juejin.cn/post/6844904001528397837#heading-9)

 (推荐阅读)

## https协议

- 端口 443

### 问题

- Q1：如何在网络中安全的将数据加密 传给 对方呢？
  - A1：加密
- Q2：用什么方式加密么？
  - A2：对称加密 -> 秘钥传送安全问题
  - A2：非对称加密 -> 公钥传送安全问题
- Q3：解决方案
  - A3：使用 权威认证机构(CA) 来证明 网站的公钥没被篡改 -- https

### 基本流程

- 操作系统内置 权威证书认证机构(`CA-CertificateAuthority`)的 **机构证书X**

- 网站A 获取认证证书

  - 生成自己的 **公钥A** 和 **私钥A**

  - 找认证机构 生成

    网站A证书

    ，并保存在服务器中

    - 证书(SSL)包含信息：
      - 网站的域名，证书有效期，证书颁发机构
      - 网站自己的**公钥A**等

- 浏览器 请求获取 **网站A证书**

- 浏览器 用

  机构证书X

   解密

  网站A证书

  - 解密成功：获取 `网站A公钥`(只要解密成功，就说明 是 机构认证的)
  - 解密失败：认证失败

- 浏览器 将自己的秘钥 发给服务器

  - 使用对称加密算法 生成 `会话秘钥B`
  - 使用`网站A公钥` 对 `会话秘钥B` 做加密，并发给 服务器

- 浏览器和服务器 使用 `浏览器会话秘钥B` 来对 请求报文 和 响应报文 做加密

![img](https://raw.githubusercontent.com/CNsixgod/oss-img/master/8bdc86bf32d14a5fb1216e5e0711687b%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A3024%3A0%3A0%3A0.awebp)

### 证书认证机构

- 如果证书颁发机构过多的话，不容易识别，防伪和管理，于是形成了少数几家国际权威的证书颁发机构，这些机构非常权威，默认是所有人都可信的，它们成为根证书。
- 但是除了这些机构外，其他的机构也需要被信任，因而，需要这些权威的机构去授信颁发证书，于是就形成了一级证书机构，一级证书机构又可以继续授信下级机构，于是成为树状结构，对于任何一个组织到根证书就是链状结构。

### CA证书的保存

- 保存在系统中

![img](https://raw.githubusercontent.com/CNsixgod/oss-img/master/6zSXBeqqxHxaD5.webp)
